package test

import busymachines.core._
import busymachines.effects._

object Password {

  def apply(pw: String): Result[Password] =
    if (pw.length < 6) Result.fail(InvalidInputFailure("Password needs to have at least 6 characters"))
    else Result.pure(new Password(pw))

}

final class Password private (val plainText: String) {

  //generated by IntelliJ
  override def equals(other: Any): Boolean = other match {
    case that: Password =>
      plainText == that.plainText
    case _ => false
  }

  //generated by IntelliJ
  override def hashCode(): Int = {
    val state = Seq(plainText)
    state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b)
  }
}

object Email {

  def apply(em: String): Result[Email] =
    if (!em.contains("@")) Result.fail(InvalidInputFailure("Email must contain: @"))
    else Result.pure(new Email(em))

}

final class Email private (val plainTextEmail: String) {

  //generated by IntelliJ
  override def equals(other: Any): Boolean = other match {
    case that: Email =>
      plainTextEmail == that.plainTextEmail
    case _ => false
  }

  //generated by IntelliJ
  override def hashCode(): Int = {
    val state = Seq(plainTextEmail)
    state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b)
  }
}

object UserRole {

  def fromName(s: String): Result[UserRole] =
    nameToRole
      .get(s)
      .asResult(InvalidInputFailure(s"UserRole has to be one of $allString, but was: $s"))

  lazy val all = Set(
    Admin,
    Regular,
    IAmBecomeDeath
  )

  lazy val nameToRole: Map[String, UserRole] = all.map(s => (s.productPrefix, s)).toMap

  lazy val allString = all.mkString("[", ",", "]")
}

sealed trait UserRole extends Product

case object Admin          extends UserRole
case object Regular        extends UserRole
case object IAmBecomeDeath extends UserRole

case class User(email: Email, pwd: Password, role: UserRole)
